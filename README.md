Анализ алгоритмов сортировки и поиска для Python 3
1. Блочная (Корзинная) Сортировка
Определение: Блочная сортировка (bucket sort) — это алгоритм, который распределяет
элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их
значений. После этого каждая корзина сортируется отдельно (либо тем же методом
рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины
объединяются обратно в один массив.

Принцип работы:

Инициализация корзин - оператор buckets = [[] for _ in range(n)] создает пустые корзины

Распределение элементов - цикл for num in arr: с оператором buckets[index].append(num) распределяет элементы по корзинам

Сортировка корзин - цикл for bucket in buckets: с оператором bucket.sort() сортирует каждую корзину

Объединение результатов - цикл for bucket in buckets: с оператором result.extend(bucket) объединяет корзины

Временная сложность:

Худший случай: O(n²)

Объяснение: Сложность зависит от распределения элементов. В худшем случае все элементы попадают в одну корзину.

2. Блинная Сортировка
Определение: Блинная сортировка (pancake sort) — это метод, основанный на операции
переворота (reversal) части массива. В отличие от большинства алгоритмов, которые
обменивают соседние элементы или выбирают опорные точки, здесь единственная
разрешённая операция — переворот префикса массива до выбранного индекса.


Принцип работы:

Поиск максимума - функция find_max_index() находит индекс максимального элемента

Переворот до максимума - оператор flip(arr, max_index) перемещает максимум в начало

Переворот сегмента - оператор flip(arr, curr_size - 1) перемещает максимум в конец текущего сегмента

Уменьшение сегмента - оператор curr_size -= 1 уменьшает размер обрабатываемой части

Временная сложность:

Все случаи: O(n²)

Объяснение: Алгоритм требует O(n) переворотов, каждый переворот занимает O(n) времени.

3. Сортировка Бусинами (Гравитационная)
Определение: Сортировка бусинами (bead sort), также известная как гравитационная
сортировка, моделирует естественное поведение бусин, падающих вниз под действием
гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл
Диннин в 2002 году.

Инициализация абака - оператор abacus = [[0] * len(arr) for _ in range(max_val)] создает матрицу бусин

Размещение бусин - вложенные циклы for i, num in enumerate(arr): и for j in range(num): размещают бусины

Падение бусин - цикл for i in range(max_val): с подсчетом bead_count симулирует гравитацию

Подсчет результата - вложенные циклы преобразуют матрицу обратно в числа

Временная сложность:

Все случаи: O(n + S), где S - сумма элементов

Объяснение: Время зависит от размера чисел в массиве.

4. Поиск Скачками
Определение: Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при которой алгоритм «прыгает» через определённое число элементов (обычно через  n), чтобы быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного
диапазона

Принцип работы:

Вычисление шага - оператор step = int(math.sqrt(n)) определяет размер прыжка

Поиск диапазона - цикл while arr[min(step, n) - 1] < x: находит блок, содержащий элемент

Линейный поиск - цикл for i in range(prev, min(step, n)): ищет элемент в блоке

Временная сложность:
Средний случай: O(√n)

Объяснение: Оптимальный размер прыжка - √n, что дает минимальное количество сравнений.

5. Экспоненциальный Поиск
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя
быстро определить диапазон, в котором может находиться искомое значение, а затем
применяет двоичный поиск в этом диапазоне.

Принцип работы:

Проверка начала - условие if arr[0] == x: проверяет первый элемент

Экспоненциальное увеличение - цикл while i < n and arr[i] <= x: с оператором i *= 2 находит диапазон

Бинарный поиск - вызов binary_search() ищет элемент в диапазоне

Временная сложность:

Все случаи: O(log n)

Объяснение: Время определяется бинарным поиском в диапазоне размером O(n).

6. Тернарный Поиск
Определение:
Тернарный поиск — это метод деления диапазона поиска на три части (в отличие от двух в
бинарном) и рекурсивного сужения диапазона до тех пор, пока не будет найден элемент или
экстремум функции (в зависимости от задачи)

Принцип работы:

Разделение на трети - операторы mid1 = left + (right - left) // 3 и mid2 = right - (right - left) // 3 делят диапазон

Проверка точек - условия if arr[mid1] == x: и if arr[mid2] == x: проверяют точки деления

Рекурсивный поиск - рекурсивные вызовы ternary_search() сужают диапазон поиска

Временная сложность:

Все случаи: O(log₃n)

Объяснение: Сложность также O(log₃n), но число сравнений на шаг выше, чем в двоичном поиске. На каждой итерации поисковое пространство уменьшается в 3 раза.