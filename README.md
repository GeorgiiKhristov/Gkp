Определение:
Сортировка выбором (Selection Sort) — это алгоритм, который разделяет массив на две части: отсортированную и неотсортированную. На каждом шаге он находит минимальный элемент в неотсортированной части и меняет его местами с первым элементом этой части.

Анализ алгоритма и операторы:

Внешний цикл: for или while для прохода по всем элементам, кроме последнего. Этот цикл определяет границу между отсортированной и неотсортированной частью.

Внутренний цикл: Еще один for для поиска минимального элемента в неотсортированной части. Проходит от текущего индекса внешнего цикла до конца массива.

Операция сравнения: if для сравнения элементов во внутреннем цикле и обновления индекса минимального элемента.

Операция обмена: После завершения внутреннего цикла используется оператор swap (или ручной обмен через временную переменную) для помещения найденного минимума на его правильную позицию.

Временная сложность: O(n²)
Объяснение: Внешний цикл выполняется n-1 раз. Внутренний цикл на i-ой итерации выполняется n-i раз. Суммарно количество сравнений = (n-1) + (n-2) + ... + 1 = n(n-1)/2 → O(n²).

2. Сортировка обменом (Пузырьковая сортировка - Bubble Sort)
Краткое определение: Алгоритм многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке.

Анализ алгоритма и операторы:

Внешний цикл: for или while, который контролирует количество проходов по массиву. Условие выхода — отсутствие обменов за проход (оптимизация).

Внутренний цикл: for проходит от начала массива до границы еще не отсортированных элементов. На каждой итерации он сравнивает пары [j] и [j+1].

Условный оператор: if внутри внутреннего цикла проверяет, нужно ли менять местами соседние элементы.

Операция обмена: swap (или ручной обмен) выполняется внутри if, когда условие истинно.

Флаг: Часто используется булева переменная (swapped), которая сбрасывается в начале прохода и устанавливается при обмене. Этот flag проверяется в условии внешнего цикла while.

Временная сложность: O(n²)
Объяснение: В худшем случае (обратно отсортированный массив) внешний цикл выполнится n раз, а внутренний — в среднем n/2 раз, что дает O(n²). С флагом лучший случай (отсортированный массив) — O(n).

3. Сортировка вставками (Insertion Sort)
Краткое определение: Алгоритм строит отсортированную последовательность, вставляя каждый новый элемент в правильную позицию внутри уже отсортированной части.

Анализ алгоритма и операторы:

Внешний цикл: for, который перебирает элементы, начиная со второго (i = 1). Каждый элемент — это "ключ" для вставки.

Ключевая переменная: Текущий элемент key = arr[i] сохраняется перед сдвигом.

Внутренний цикл: while или for, который работает в отсортированной части (от i-1 до 0). Условие цикла: j >= 0 && arr[j] > key.

Операция сдвига: В теле внутреннего цикла выполняется не обмен, а сдвиг: arr[j+1] = arr[j].

Вставка: После выхода из внутреннего цикла (когда найдена позиция) ключ вставляется: arr[j+1] = key.

Временная сложность: O(n²)
Объяснение: В худшем случае (обратный порядок) для каждого из n элементов внутренний цикл сдвигает почти всю отсортированную часть. Количество операций ~ n²/2 → O(n²). Лучший случай (отсортированный массив) — O(n), т.к. внутренний цикл не выполняется.

4. Сортировка слиянием (Merge Sort)
Краткое определение: Алгоритм "разделяй и властвуй". Рекурсивно разбивает массив пополам, сортирует каждую половину, а затем сливает отсортированные половины.

Анализ алгоритма и операторы:

Рекурсия: Основная функция вызывает саму себя (mergeSort(left), mergeSort(right)). Базовый случай рекурсии — if (low >= high) (массив из 0 или 1 элемента).

Оператор деления: Нахождение середины: mid = (low + high) / 2.

Циклы в слиянии:

while-циклы для попарного сравнения элементов из двух половин и помещения меньшего во временный массив.

Последующие while-циклы для копирования оставшихся элементов из любой из половин.

Финальный цикл: for для копирования отсортированного временного массива обратно в исходный.

Временная сложность: O(n log n)
Объяснение: Глубина рекурсии — O(log n). На каждом уровне рекурсии выполняется операция слияния всех n элементов (через циклы в функции merge) за O(n). Итого: O(n) * O(log n) = O(n log n).

5. Сортировка Шелла (Shell Sort)
Краткое определение: Улучшенная сортировка вставками, которая сравнивает элементы на определенном расстоянии (шаге), постепенно уменьшая шаг до 1.

Анализ алгоритма и операторы:

Внешний цикл: for или while для перебора последовательности шагов (gap). Начинается с большого gap и уменьшается до 1.

Средний цикл: for, который проходит по элементам, начиная с gap-того. Каждый такой элемент является "ключом" для своей группы.

Внутренний цикл: while, очень похожий на внутренний цикл вставками, но сравнивающий и сдвигающий элементы не на 1, а на gap. Условие: j >= gap && arr[j - gap] > temp.

Временная сложность: O(n log² n)
Объяснение: Сложность зависит от выбора gap. Для лучших последовательностей (Седжвика) внутренние циклы работают быстрее, чем O(n²), из-за раннего устранения беспорядка. Эмпирически около O(n^(3/2)) или O(n log² n).

6. Быстрая сортировка (Quick Sort)
Краткое определение: Алгоритм "разделяй и властвуй". Выбирает опорный элемент и перераспределяет другие элементы так, чтобы меньшие оказались слева, а большие — справа.

Анализ алгоритма и операторы:

Рекурсия: Основная функция вызывает саму себя для левого и правого подмассивов: quickSort(low, pi - 1), quickSort(pi + 1, high). Базовый случай — if (low < high).

Функция Partition: Сердце алгоритма.

Выбор опоры: pivot = arr[high] (частая стратегия).

Индекс: i = (low - 1) — индекс меньшего элемента.

Цикл: for (j = low; j <= high - 1; j++) проходит по всем элементам, кроме опоры.

Условие: if (arr[j] < pivot) — если текущий элемент меньше опоры.

Инкремент и обмен: Если условие истинно, увеличивается i и происходит swap(arr[i], arr[j]).

Финальный обмен: После цикла swap(arr[i + 1], arr[high]) ставит опору на правильное место.

Временная сложность: O(n log n)
Объяснение: В среднем случае разбиение делит массив на две ~равные части (глубина рекурсии O(log n)), а на каждом уровне выполняется работа O(n) (цикл в partition). Итого O(n log n). В худшем (плохое разбиение) — O(n²).

7. Пирамидальная сортировка (Heapsort)
Краткое определение: Алгоритм использует структуру данных "двочная куча". Строит max-кучу, затем последовательно извлекает максимальный элемент.

Анализ алгоритма и операторы:

Построение кучи: Цикл for, вызывающий heapify для всех нелистовых узлов (от n/2 - 1 до 0).

Функция Heapify (рекурсивная или итеративная):

Условные операторы: if для нахождения наибольшего элемента среди корня и его потомков (left и right).

Рекурсия/Цикл: Если наибольший — не корень, происходит swap и рекурсивный вызов heapify для поврежденного поддерева (или цикл while).

Основной цикл сортировки: for (i = n - 1; i > 0; i--). На каждой итерации:

swap(arr[0], arr[i]) (перемещает корень (макс.) в конец).

Вызов heapify(arr, i, 0) для уменьшенной кучи.

Временная сложность: O(n log n)
Объяснение: Построение кучи — O(n). Затем выполняется n извлечений корня. Каждое извлечение (включая heapify) занимает O(log n) времени. Итог: O(n) + O(n * log n) = O(n log n).

8. Последовательный поиск (Linear Search)
Краткое определение: Простейший алгоритм поиска, который последовательно проверяет каждый элемент коллекции.

Анализ алгоритма и операторы:

Цикл: Один for или while, проходящий по всем индексам массива от 0 до n-1.

Условный оператор: if внутри цикла проверяет условие arr[i] == key (совпадение с искомым элементом).

Оператор возврата/прерывания: При успешном нахождении — return i (возврат индекса) или break (выход из цикла). Если цикл завершился без нахождения — return -1.

Временная сложность: O(n)
Объяснение: В худшем и среднем случае (элемент в конце или отсутствует) цикл выполнится n раз, что дает O(n). В лучшем случае (элемент первый) — O(1).
