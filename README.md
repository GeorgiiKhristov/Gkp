Анализ алгоритмов сортировки и поиска для Python 3
1. Блочная (Корзинная) Сортировка
Определение: Блочная сортировка (bucket sort) — это алгоритм, который распределяет
элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их
значений. После этого каждая корзина сортируется отдельно (либо тем же методом
рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины
объединяются обратно в один массив.

Принцип работы:

Инициализация корзин - оператор buckets = [[] for _ in range(n)] создает пустые корзины

Распределение элементов - цикл for num in arr: с оператором buckets[index].append(num) распределяет элементы по корзинам

Сортировка корзин - цикл for bucket in buckets: с оператором bucket.sort() сортирует каждую корзину

Объединение результатов - цикл for bucket in buckets: с оператором result.extend(bucket) объединяет корзины

Временная сложность:

Худший случай: O(n²)

Объяснение: Распределение по корзинам: O(n) - каждый элемент обрабатывается один раз

Сортировка корзин: зависит от распределения элементов

Худший случай (все элементы в одной корзине): одна корзина содержит все n элементов, сортировка занимает O(n log n) или O(n²) в зависимости от алгоритма

Объединение корзин: O(n) - все элементы копируются обратно

2. Блинная Сортировка
Определение: Блинная сортировка (pancake sort) — это метод, основанный на операции
переворота (reversal) части массива. В отличие от большинства алгоритмов, которые
обменивают соседние элементы или выбирают опорные точки, здесь единственная
разрешённая операция — переворот префикса массива до выбранного индекса.


Принцип работы:

Поиск максимума - функция find_max_index() находит индекс максимального элемента

Переворот до максимума - оператор flip(arr, max_index) перемещает максимум в начало

Переворот сегмента - оператор flip(arr, curr_size - 1) перемещает максимум в конец текущего сегмента

Уменьшение сегмента - оператор curr_size -= 1 уменьшает размер обрабатываемой части

Временная сложность:

Все случаи: O(n²)

Объяснение:Количество переворотов: O(n) - каждый элемент требует своего переворота

Стоимость одного переворота: O(n) - переворот подмассива размера k требует k/2 операций

Общая сложность: O(n) × O(n) = O(n²)

Каждый элемент в худшем случае требует двух переворотов: сначала чтобы поднять максимум в начало, затем чтобы опустить его на нужную позицию

3. Сортировка Бусинами (Гравитационная)
Определение: Сортировка бусинами (bead sort), также известная как гравитационная
сортировка, моделирует естественное поведение бусин, падающих вниз под действием
гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл
Диннин в 2002 году.

Инициализация абака - оператор abacus = [[0] * len(arr) for _ in range(max_val)] создает матрицу бусин

Размещение бусин - вложенные циклы for i, num in enumerate(arr): и for j in range(num): размещают бусины

Падение бусин - цикл for i in range(max_val): с подсчетом bead_count симулирует гравитацию

Подсчет результата - вложенные циклы преобразуют матрицу обратно в числа

Временная сложность:

Все случаи: O(n + S), где S - сумма элементов

Объяснение: Инициализация абака: O(m × n), где m = max(arr) - максимальный элемент

Размещение бусин: O(S) - каждая бусина обрабатывается отдельно, S = сумма всех элементов

Падение бусин: O(m × n) - для каждого уровня обрабатываются все столбцы

Подсчет результата: O(m × n)

Так как m может быть сравним с S/n, общая сложность O(n + S)

4. Поиск Скачками
Определение: Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при которой алгоритм «прыгает» через определённое число элементов (обычно через  n), чтобы быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного
диапазона

Принцип работы:

Вычисление шага - оператор step = int(math.sqrt(n)) определяет размер прыжка

Поиск диапазона - цикл while arr[min(step, n) - 1] < x: находит блок, содержащий элемент

Линейный поиск - цикл for i in range(prev, min(step, n)): ищет элемент в блоке

Временная сложность:
Средний случай: O(√n)

Объяснение:Обоснование:

Оптимальный размер прыжка: √n - минимизирует сумму количества прыжков и линейного поиска

Количество прыжков: O(n/√n) = O(√n) - массив размера n разбивается на блоки по √n элементов

Линейный поиск в блоке: O(√n) - размер блока √n элементов

Общая сложность: O(√n) + O(√n) = O(√n)

Лучший случай: элемент находится в первой позиции первого блока
5. Экспоненциальный Поиск
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя
быстро определить диапазон, в котором может находиться искомое значение, а затем
применяет двоичный поиск в этом диапазоне.

Принцип работы:

Проверка начала - условие if arr[0] == x: проверяет первый элемент

Экспоненциальное увеличение - цикл while i < n and arr[i] <= x: с оператором i *= 2 находит диапазон

Бинарный поиск - вызов binary_search() ищет элемент в диапазоне

Временная сложность:

Все случаи: O(log n)

Объяснение:Фаза экспоненциального увеличения: O(log i), где i - позиция элемента

Размер диапазона удваивается на каждом шаге: 1, 2, 4, 8, ..., пока не превысит позицию элемента

Количество шагов: O(log i)

Фаза бинарного поиска: O(log n)

Размер найденного диапазона: от i/2 до min(i, n), то есть O(i)

Так как i ≤ n, бинарный поиск занимает O(log n)

Общая сложность: O(log i) + O(log n) = O(log n)

6. Тернарный Поиск
Определение:
Тернарный поиск — это метод деления диапазона поиска на три части (в отличие от двух в
бинарном) и рекурсивного сужения диапазона до тех пор, пока не будет найден элемент или
экстремум функции (в зависимости от задачи)

Принцип работы:

Разделение на трети - операторы mid1 = left + (right - left) // 3 и mid2 = right - (right - left) // 3 делят диапазон

Проверка точек - условия if arr[mid1] == x: и if arr[mid2] == x: проверяют точки деления

Рекурсивный поиск - рекурсивные вызовы ternary_search() сужают диапазон поиска

Временная сложность:

Все случаи: O(log₃n)


Объяснение:Коэффициент уменьшения: на каждой итерации поисковое пространство уменьшается в 3 раза

Количество итераций: log₃n

После k итераций остаётся n/(3^k) элементов

n/(3^k) = 1 ⇒ k = log₃n

Работа на одной итерации: O(1) - сравнение с двумя точками

Общая сложность: O(log₃n) × O(1) = O(log₃n)
