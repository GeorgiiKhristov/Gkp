
1. Сортировка выбором (Selection Sort)
Краткое определение: Алгоритм на каждой итерации находит минимальный (или максимальный) элемент в неотсортированной части массива и меняет его местами с первым элементом неотсортированной части.

Анализ алгоритма:

Принцип работы: Массив мысленно делится на две части: отсортированную (в начале) и неотсортированную. Изначально отсортированная часть пуста. На каждом шаге алгоритм:

Находит наименьший элемент в неотсортированной части.

Меняет его местами с первым элементом неотсортированной части.

Увеличивает границу отсортированной части на один элемент.

Достоинства: Прост в понимании и реализации. Не требует дополнительной памяти (сортировка на месте).

Недостатки: Медленный на больших массивах. Неустойчив (может менять относительный порядок одинаковых элементов). Производит много обменов, но всегда O(n) обменов, что может быть полезно, если обмены очень дороги (например, с данными на внешних носителях).

Временная сложность:

Средний случай: O(n²)

Объяснение сложности: Вне зависимости от исходного порядка элементов, алгоритм всегда выполнит примерно n²/2 сравнений. Цикл проходит n раз, и на каждой итерации i происходит поиск минимума среди (n - i) элементов. Сумма сравнений = (n-1) + (n-2) + ... + 1 = n(n-1)/2, что является O(n²).

2. Сортировка обменом (Пузырьковая сортировка - Bubble Sort)
Краткое определение: Алгоритм многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Проходы повторяются до тех пор, пока массив не будет отсортирован.

Анализ алгоритма:

Принцип работы: На каждом проходе "всплывает" самый большой элемент на свою позицию в конце массива, подобно пузырьку воздуха в воде. После каждого прохода область неотсортированных элементов уменьшается.

Достоинства: Чрезвычайно прост для понимания и реализации.

Недостатки: Очень медленный и неэффективный на практике даже среди других O(n²) алгоритмов.

Временная сложность:

Средний случай: O(n²)


Объяснение сложности: В худшем случае (массив отсортирован в обратном порядке) требуется n проходов, на каждом из которых выполняется n-i сравнений и множество обменов. Общее количество операций пропорционально n². В лучшем случае (массив уже отсортирован) с флагом swapped алгоритм сделает всего один проход за O(n).

3. Сортировка вставками (Insertion Sort)
Краткое определение: Алгоритм строит отсортированную последовательность, по одному элементу за раз, вставляя каждый новый элемент в правильную позицию внутри уже отсортированной части.

Анализ алгоритма:

Принцип работы: Массив делится на отсортированную часть (слева) и неотсортированную (справа). Алгоритм берет первый элемент из неотсортированной части и вставляет его в отсортированную, сдвигая элементы для освобождения места.

Достоинства: Прост в реализации. Эффективен на небольших наборах данных и практически отсортированных массивах. Устойчив. Сортировка на месте.

Недостатки: Медленный на больших и случайных массивах.

Временная сложность:

Средний случай: O(n²)

Объяснение сложности: В худшем случае для вставки каждого нового элемента придется сдвигать всю отсортированную часть. Количество операций будет 1 + 2 + ... + (n-1) = n(n-1)/2, т.е. O(n²). В лучшем случае каждый новый элемент сразу оказывается на своем месте, и для его вставки требуется O(1), итого O(n).

4. Сортировка слиянием (Merge Sort)
Краткое определение: Алгоритм "разделяй и властвуй". Он рекурсивно разбивает массив пополам, сортирует каждую половину, а затем сливает отсортированные половины в один отсортированный массив.

Анализ алгоритма:

Принцип работы:

Разделение: Массив рекурсивно делится пополам, пока не останутся подмассивы из одного элемента (которые по определению отсортированы).

Слияние: Два отсортированных подмассива сливаются в один, путем последовательного сравнения их элементов и выбора наименьшего.

Достоинства: Гарантированная временная сложность O(n log n). Устойчив (если реализован корректно). Хорошо подходит для сортировки связных списков и внешней сортировки (когда данные не помещаются в оперативную память).

Недостатки: Требует дополнительной памяти O(n) для временного массива.

Временная сложность:


Средний случай: O(n log n)


Объяснение сложности: Глубина рекурсии — log n (так как массив делится пополам каждый раз). На каждом уровне рекурсии выполняется операция слияния всех элементов, которая занимает O(n) времени. Таким образом, общая сложность — O(n) * O(log n) = O(n log n).

5. Сортировка Шелла (Shell Sort)
Краткое определение: Это обобщение сортировки вставками. Алгоритм сравнивает и меняет местами элементы, находящиеся на определенном расстоянии (шаге) друг от друга, постепенно уменьшая этот шаг до 1.

Анализ алгоритма:

Принцип работы: Вместо сравнения соседних элементов, как в пузырьковой или вставками, Шелл сортирует элементы на далеких позициях, что позволяет быстрее "проталкивать" мелкие элементы в начало, а крупные — в конец. Последовательность шагов (gaps) критически влияет на производительность.

Достоинства: Эффективнее O(n²)-алгоритмов. Сортировка на месте. Временная сложность сильно зависит от выбранной последовательности шагов.

Недостатки: Сложность анализа. Неустойчив.

Временная сложность:

Зависит от выбора шага (gap sequence).

Худший случай: Может варьироваться от O(n²) до O(n log² n).

Для лучших последовательностей (например, последовательность Седжвика): O(n log² n)

Объяснение сложности: Точный анализ сложен. Идея в том, что на начальных больших шагах алгоритм делает грубую, но быструю сортировку, а на маленьких шагах (близких к 1) массив оказывается почти отсортирован, и сортировка вставками работает за O(n). Эмпирически, для хороших последовательностей, сложность лучше, чем O(n²).

6. Быстрая сортировка (Quick Sort)
Краткое определение: Алгоритм "разделяй и властвуй". Он выбирает "опорный" элемент и перераспределяет другие элементы массива так, чтобы элементы меньше опорного оказались слева от него, а больше — справа. Затем алгоритм рекурсивно применяется к двум подмассивам.

Анализ алгоритма:

Принцип работы:

Выбор опоры (pivot): Выбирается элемент из массива (часто случайный, средний или последний).

Разбиение (partition): Массив переупорядочивается так, что все элементы меньше опоры идут перед ней, а все большие — после.

Рекурсия: Алгоритм рекурсивно применяется к подмассивам слева и справа от опоры.

Достоинства: В среднем один из самых быстрых алгоритмов на практике. Сортировка на месте.

Недостатки: Неустойчив. В худшем случае имеет сложность O(n²), хотя этого можно избежать с помощью рандомизации выбора опоры.

Временная сложность:

Средний случай: O(n log n)

Объяснение сложности: В среднем случае разбиение делит массив на две примерно равные части. Глубина рекурсии будет log n, а на каждом уровне выполняется работа O(n) (операция разбиения). Итого O(n log n). В худшем случае глубина рекурсии n, что дает O(n²).

7. Пирамидальная сортировка (Heapsort)
Краткое определение: Алгоритм использует структуру данных "двочная куча" (пирамида). Он строит из массива max-кучу, где наибольший элемент находится в корне, затем последовательно извлекает его и перестраивает кучу.

Анализ алгоритма:

Принцип работы:

Построение кучи: Неупорядоченный массив преобразуется в структуру max-кучи.

Извлечение максимума: Максимальный элемент (корень) меняется местами с последним элементом кучи. Размер кучи уменьшается на 1.

Перестроение кучи: Нарушенное свойство кучи восстанавливается (процедура heapify).

Повторение: Шаги 2-3 повторяются, пока в куче не останется один элемент.

Достоинства: Сортировка на месте. Имеет гарантированную сложность O(n log n). Не требует дополнительной памяти.

Недостатки: Неустойчив. Обычно медленнее, чем хорошо реализованная быстрая сортировка на практике, из-за большего количества сравнений и обменов.

Временная сложность:

Средний случай: O(n log n)


Объяснение сложности: Построение кучи из неупорядоченного массива выполняется за O(n). Затем выполняется n извлечений корня. Каждое извлечение (включая перестроение кучи heapify) занимает O(log n) времени. Итоговая сложность: O(n) + O(n * log n) = O(n log n).

8. Последовательный поиск (Linear Search)
Краткое определение: Простейший алгоритм поиска, который последовательно проверяет каждый элемент коллекции до тех пор, пока не будет найден искомый элемент или пока не будут проверены все элементы.

Анализ алгоритма:

Принцип работы: Алгоритм начинает с первого элемента и сравнивает его с искомым значением (ключом). Если совпадение есть, поиск завершен. Если нет, алгоритм переходит к следующему элементу и повторяет процесс.

Достоинства: Прост в реализации. Не требует предварительной сортировки данных.

Недостатки: Неэффективен на больших наборах данных.

Временная сложность:

Средний случай: O(n)(элемент находится на первой позиции)
Объяснение сложности: В худшем и среднем случае алгоритму, возможно, придется проверить все n элементов, что дает линейную зависимость O(n). В лучшем случае элемент находится сразу, что занимает константное время O(1).
