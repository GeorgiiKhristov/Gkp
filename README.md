
1. Сортировка выбором (Selection Sort)
Краткое определение: Алгоритм на каждой итерации находит минимальный (или максимальный) элемент в неотсортированной части массива и меняет его местами с первым элементом неотсортированной части.

Анализ алгоритма:

Принцип работы: Массив мысленно делится на две части: отсортированную (в начале) и неотсортированную. Изначально отсортированная часть пуста. На каждом шаге алгоритм:

Находит наименьший элемент в неотсортированной части.

Меняет его местами с первым элементом неотсортированной части.

Увеличивает границу отсортированной части на один элемент.

Временная сложность:

Средний случай: O(n²)

Объяснение сложности: Вне зависимости от исходного порядка элементов, алгоритм всегда выполнит примерно n²/2 сравнений. Цикл проходит n раз, и на каждой итерации i происходит поиск минимума среди (n - i) элементов. Сумма сравнений = (n-1) + (n-2) + ... + 1 = n(n-1)/2, что является O(n²).

2. Сортировка обменом (Пузырьковая сортировка - Bubble Sort)
Краткое определение: Алгоритм многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Проходы повторяются до тех пор, пока массив не будет отсортирован.

Анализ алгоритма:

Принцип работы: На каждом проходе "всплывает" самый большой элемент на свою позицию в конце массива, подобно пузырьку воздуха в воде. После каждого прохода область неотсортированных элементов уменьшается.

Временная сложность:

Средний случай: O(n²)

Объяснение сложности: В худшем случае (массив отсортирован в обратном порядке) требуется n проходов, на каждом из которых выполняется n-i сравнений и множество обменов. Общее количество операций пропорционально n². В лучшем случае (массив уже отсортирован) с флагом swapped алгоритм сделает всего один проход за O(n).

3. Сортировка вставками (Insertion Sort)
Краткое определение: Алгоритм строит отсортированную последовательность, по одному элементу за раз, вставляя каждый новый элемент в правильную позицию внутри уже отсортированной части.

Анализ алгоритма:

Принцип работы: Массив делится на отсортированную часть (слева) и неотсортированную (справа). Алгоритм берет первый элемент из неотсортированной части и вставляет его в отсортированную, сдвигая элементы для освобождения места.

Временная сложность:

Средний случай: O(n²)

Объяснение сложности: В худшем случае для вставки каждого нового элемента придется сдвигать всю отсортированную часть. Количество операций будет 1 + 2 + ... + (n-1) = n(n-1)/2, т.е. O(n²). В лучшем случае каждый новый элемент сразу оказывается на своем месте, и для его вставки требуется O(1), итого O(n).

4. Сортировка слиянием (Merge Sort)
Краткое определение: Алгоритм "разделяй и властвуй". Он рекурсивно разбивает массив пополам, сортирует каждую половину, а затем сливает отсортированные половины в один отсортированный массив.

Анализ алгоритма:

Принцип работы:

Разделение: Массив рекурсивно делится пополам, пока не останутся подмассивы из одного элемента (которые по определению отсортированы).

Слияние: Два отсортированных подмассива сливаются в один, путем последовательного сравнения их элементов и выбора наименьшего.

Временная сложность:

Средний случай: O(n log n)

Объяснение сложности: Глубина рекурсии — log n (так как массив делится пополам каждый раз). На каждом уровне рекурсии выполняется операция слияния всех элементов, которая занимает O(n) времени. Таким образом, общая сложность — O(n) * O(log n) = O(n log n).

5. Сортировка Шелла (Shell Sort)
Краткое определение: Это обобщение сортировки вставками. Алгоритм сравнивает и меняет местами элементы, находящиеся на определенном расстоянии (шаге) друг от друга, постепенно уменьшая этот шаг до 1.

Анализ алгоритма:

Принцип работы: Вместо сравнения соседних элементов, как в пузырьковой или вставками, Шелл сортирует элементы на далеких позициях, что позволяет быстрее "проталкивать" мелкие элементы в начало, а крупные — в конец. Последовательность шагов (gaps) критически влияет на производительность.

Временная сложность:

Зависит от выбора шага (gap sequence).

Худший случай: Может варьироваться от O(n²) до O(n log² n).

Для лучших последовательностей (например, последовательность Седжвика): O(n log² n)

Объяснение сложности: Точный анализ сложен. Идея в том, что на начальных больших шагах алгоритм делает грубую, но быструю сортировку, а на маленьких шагах (близких к 1) массив оказывается почти отсортирован, и сортировка вставками работает за O(n). Эмпирически, для хороших последовательностей, сложность лучше, чем O(n²).

6. Быстрая сортировка (Quick Sort)
Краткое определение: Алгоритм "разделяй и властвуй". Он выбирает "опорный" элемент и перераспределяет другие элементы массива так, чтобы элементы меньше опорного оказались слева от него, а больше — справа. Затем алгоритм рекурсивно применяется к двум подмассивам.

Анализ алгоритма:

Принцип работы:

Выбор опоры (pivot): Выбирается элемент из массива (часто случайный, средний или последний).

Разбиение (partition): Массив переупорядочивается так, что все элементы меньше опоры идут перед ней, а все большие — после.

Рекурсия: Алгоритм рекурсивно применяется к подмассивам слева и справа от опоры.

Временная сложность:

Средний случай: O(n log n)

Объяснение сложности: В среднем случае разбиение делит массив на две примерно равные части. Глубина рекурсии будет log n, а на каждом уровне выполняется работа O(n) (операция разбиения). Итого O(n log n). В худшем случае глубина рекурсии n, что дает O(n²).

7. Пирамидальная сортировка (Heapsort)
Краткое определение: Алгоритм использует структуру данных "двочная куча" (пирамида). Он строит из массива max-кучу, где наибольший элемент находится в корне, затем последовательно извлекает его и перестраивает кучу.

Анализ алгоритма:

Принцип работы:

Построение кучи: Неупорядоченный массив преобразуется в структуру max-кучи.

Извлечение максимума: Максимальный элемент (корень) меняется местами с последним элементом кучи. Размер кучи уменьшается на 1.

Перестроение кучи: Нарушенное свойство кучи восстанавливается (процедура heapify).

Повторение: Шаги 2-3 повторяются, пока в куче не останется один элемент.

Временная сложность:

Средний случай: O(n log n)


Объяснение сложности: Построение кучи из неупорядоченного массива выполняется за O(n). Затем выполняется n извлечений корня. Каждое извлечение (включая перестроение кучи heapify) занимает O(log n) времени. Итоговая сложность: O(n) + O(n * log n) = O(n log n).

8. Последовательный поиск (Linear Search)
Краткое определение: Простейший алгоритм поиска, который последовательно проверяет каждый элемент коллекции до тех пор, пока не будет найден искомый элемент или пока не будут проверены все элементы.

Анализ алгоритма:

Принцип работы: Алгоритм начинает с первого элемента и сравнивает его с искомым значением (ключом). Если совпадение есть, поиск завершен. Если нет, алгоритм переходит к следующему элементу и повторяет процесс.

Временная сложность:

Средний случай: O(n)(элемент находится на первой позиции)
Объяснение сложности: В худшем и среднем случае алгоритму, возможно, придется проверить все n элементов, что дает линейную зависимость O(n). В лучшем случае элемент находится сразу, что занимает константное время O(1).
