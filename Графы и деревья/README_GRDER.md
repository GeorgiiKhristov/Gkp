Лабораторная работа №4
Реализация деревьев на языках программирования Python, Java, C++
Питон:
Связи и Null: Используется система ссылок на объекты, роль «нулевого» элемента играет специальный объект None.
Классы: Применяются отдельные классы (Node, Tree) для представления структуры дерева.
Память: Управление памятью осуществляется автоматически посредством сборщика мусора.
Вставка (не рекурсивная): Необходимо отслеживать два узла — текущий (v) и предыдущий (parent), чтобы обновить левую или правую ветвь родителя при достижении пустой ссылки.
Вставка (рекурсивная): Рекурсивная функция должна возвращать новый корневой элемент поддерева, и её результат присваивается полю root, чтобы правильно обрабатывать ситуацию с изначально пустым деревом.
Java:
Связи и null: Связывание элементов производится с использованием ссылок на объекты, неиспользованные поля получают значение null.
Классы: Вершина (Node) чаще всего оформляется отдельным внутренним статическим классом внутри основного класса дерева (Tree).
Нерекурсивная вставка: Нужно держать два указателя — на текущий узел (node) и его родителя (parent); обновление связей выполняется непосредственно при обнаружении места для нового элемента.
C++:
Указатели: Основной механизм взаимодействия между вершинами — указатели (TNode*).
Инициализация: Полям-указателям обязательно требуется начальное обнуление в конструкторе (предпочтительно использовать nullptr).
Деструкция: Освобождение памяти должно происходить вручную, для чего рекомендуется реализовать деструктор (~TTree), выполняющий рекурсивное удаление всех элементов дерева.
Указатели на указатели: Возможность использовать указатели на указатели (TNode** cur) упрощает реализацию нерекурсивной вставки, позволяя прямо изменять нужный указатель без дополнительной обработки родственных узлов.
Реализация графов на языках Python, Java, C++
Питон:
Граф: Наиболее естественно представить граф с помощью словарей (dict), где ключами являются вершины, а значениями — вложенные словари соседних вершин и весов ребёр.
Приоритетная очередь: Использовать стандартную библиотеку heapq, обеспечивающую работу с очередью с приоритетом поверх обычных списков.
Значение бесконечности: Начальные расстояния задаются как float('inf').
Java:
Граф: Обычно применяется либо матрица смежности (int[][] adjMat), либо списки смежности (массив объектов типа ArrayList).
Приоритетная очередь: Для работы с очередью необходимо создать дополнительный класс (Pair), хранящий индекс вершины и вес, реализовав интерфейс Comparable для правильной сортировки.
C++:
Граф: Часто используется представление в виде вектора векторных структур (vector<vector>), где каждая запись описывает соседнюю вершину и вес соответствующего ребра.
Приоритетная очередь: Встроенный инструмент — std::priority_queue из стандартной библиотеки STL.
Значения бесконечности: Для задания начальных значений расстояний применяется макрос numeric_limits<T>::max().