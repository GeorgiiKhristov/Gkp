Задание 7. Жадный алгоритм: интервальное планирование
Условие. Даны интервалы [si,fi]. Выбрать максимальное число непересекающихся
интервалов.
Алгоритм: жадный по времени окончания.
Язык примера: Python
def interval_scheduling(intervals):
 intervals.sort(key=lambda x: x[1])
 result = []
 last_end = -1
 for start, end in intervals:
 # ДОПИСАТЬ: если интервал не пересекается с последним выбранным
 return result
Что дописать: условие добавления интервала.



Анализ работы алгоритма
Пошаговый алгоритм решения:

Шаг 1: Инициализация

python
intervals.sort(key=lambda x: x[1])
Сортируем все интервалы по времени окончания (fi) в возрастающем порядке.

Шаг 2: Подготовка структур данных

python
result = []
last_end = -1
Создаем пустой список для хранения результата и переменную для отслеживания времени окончания последнего выбранного интервала.

Шаг 3: Итерация по отсортированным интервалам

python
for start, end in intervals:
Последовательно перебираем все интервалы в порядке возрастания времени окончания.

Шаг 4: Проверка условия непересечения

python
if start >= last_end:
Проверяем, что начало текущего интервала не меньше времени окончания последнего выбранного интервала.

Шаг 5: Добавление подходящего интервала

python
    result.append([start, end])
    last_end = end
Если условие выполняется, добавляем интервал в результат и обновляем время окончания.

Оценка временной сложности:
Временная сложность: O(n log n)

Такая сложность возникает в силу следующих действий:

Сортировка интервалов: O(n log n) - это доминирующая операция

Линейный проход: O(n) - один проход по отсортированному массиву

Операции сравнения и добавления: O(1) для каждого интервала

Контрольный вопрос
Почему жадный алгоритм, выбирающий интервалы с наименьшим временем окончания, обеспечивает оптимальное решение задачи интервального планирования?

Жадный алгоритм, основанный на выборе интервалов с наименьшим временем окончания, обеспечивает оптимальное решение благодаря следующим свойствам:

Локально оптимальный выбор ведет к глобально оптимальному решению: Выбирая интервал, который заканчивается раньше всех, мы минимизируем "блокировку" временного ресурса для последующих интервалов.

Свойство безопасного выбора: Если существует оптимальное решение, содержащее определенный набор интервалов, то всегда можно заменить первый интервал в этом решении на интервал с наименьшим временем окончания без ухудшения качества решения.

Индуктивное доказательство:

Базовый случай: для одного интервала алгоритм выбирает оптимально

Предположим: для k интервалов алгоритм оптимален

Докажем: для k+1 интервалов алгоритм также оптимален
После выбора первого интервала с минимальным fi, задача сводится к аналогичной подзадаче на оставшихся интервалах

Противоречие: Предположим, существует лучшее решение. Тогда оно должно содержать хотя бы один интервал, который начинается раньше, но заканчивается позже выбранного алгоритмом интервала. Однако это противоречит стратегии минимизации времени окончания.

Таким образом, жадная стратегия выбора интервалов с минимальным временем окончания гарантирует нахождение максимального количества непересекающихся интервалов.